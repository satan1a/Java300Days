# 多线程篇 - 线程的运行状态
## 线程的五种状态：
[1] 新建<br />在实例化后，且在调用 start() 方法之前，线程处于创建状态，仅分配了内存空间，处于线程的生命周期初始状态<br />
[2] 就绪<br />调用 start() 方法后处于就绪状态，此时线程具有除 CPU 之外的所有资源，在排队等待 CPU， 由系统调度(JVM 里的线程调度器)为其分配<br />
[3] 运行<br />处于就绪状态的线程获取 CPU 资源后即处于运行状态，执行 run() 方法。处于运行状态的线程可变为 阻塞状态、就绪状态和死亡状态 <br />
[4] 阻塞/等待<br />执行了 sleep() suspend()挂起 等方法，失去所占用的资源后，处于阻塞状态。<br />特别注意的是，阻塞状态和就绪状态的等待不同是：就绪状态只缺 CPU 资源，阻塞是由各种原因引起的线程不能运行，不仅缺少 CPU 资源。<br />可再细分为：<br />
- 等待阻塞：运行状态的线程执行 wait() 方法后  
- 同步阻塞：在获取 synchronized 同步锁失败后(同步锁被其它线程占用)
- 其它阻塞：调用 sleep() 或 join() 发出 I/O 请求时。
<br />
[5] 死亡<br />执行完 run() 方法的内容或被强制终止时。线程的整个生命周期结束 <br />
- 可参见同级路径下的  images 文件夹图片

## 今日的知识点在代码注释中较多，回顾时多看源码